"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var N=require("@walletconnect/core"),k=require("@walletconnect/logger"),ae=require("@walletconnect/types"),s=require("@walletconnect/utils"),ce=require("events"),E=require("@walletconnect/time"),g=require("@walletconnect/jsonrpc-utils");function qe(m){return m&&typeof m=="object"&&"default"in m?m:{default:m}}var Pe=qe(ce);const ee="wc",te=2,ie="client",j=`${ee}@${te}:${ie}:`,Y={name:ie,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},ve={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire"},Te={database:":memory:"},se="WALLETCONNECT_DEEPLINK_CHOICE",Oe={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Ae="history",Ve="0.3",le="proposal",Ce=E.THIRTY_DAYS,he="Proposal expired",pe="session",V=E.SEVEN_DAYS,de="engine",S={wc_sessionPropose:{req:{ttl:E.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:E.ONE_DAY,prompt:!1,tag:1104},res:{ttl:E.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:E.ONE_DAY,prompt:!1,tag:1106},res:{ttl:E.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:E.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:E.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:E.ONE_DAY,prompt:!1,tag:1112},res:{ttl:E.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:E.ONE_DAY,prompt:!1,tag:1114},res:{ttl:E.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:E.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:E.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:E.FIVE_MINUTES,prompt:!1,tag:1119}}},Q={min:E.FIVE_MINUTES,max:E.SEVEN_DAYS},A={idle:"IDLE",active:"ACTIVE"},ue="request",ge=["wc_sessionPropose","wc_sessionRequest","wc_authRequest"],Ee="wc",De=1.5,we="auth",ye="authKeys",me="pairingTopics",Ie="requests",U=`${Ee}@${1.5}:${we}:`,$=`${U}:PUB_KEY`;var xe=Object.defineProperty,be=Object.defineProperties,Me=Object.getOwnPropertyDescriptors,Se=Object.getOwnPropertySymbols,Le=Object.prototype.hasOwnProperty,Ue=Object.prototype.propertyIsEnumerable,_e=(m,o,t)=>o in m?xe(m,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):m[o]=t,I=(m,o)=>{for(var t in o||(o={}))Le.call(o,t)&&_e(m,t,o[t]);if(Se)for(var t of Se(o))Ue.call(o,t)&&_e(m,t,o[t]);return m},C=(m,o)=>be(m,Me(o));class $e extends ae.IEngine{constructor(o){super(o),this.name=de,this.events=new Pe.default,this.initialized=!1,this.requestQueue={state:A.idle,queue:[]},this.sessionRequestQueue={state:A.idle,queue:[]},this.requestQueueDelay=E.ONE_SECOND,this.expectedPairingMethodMap=new Map,this.recentlyDeletedMap=new Map,this.recentlyDeletedLimit=200,this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),this.client.core.pairing.register({methods:Object.keys(S)}),this.initialized=!0,setTimeout(()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},E.toMiliseconds(this.requestQueueDelay)))},this.connect=async t=>{await this.isInitialized();const e=C(I({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(e);const{pairingTopic:i,requiredNamespaces:r,optionalNamespaces:n,sessionProperties:a,relays:c}=e;let l=i,h,d=!1;try{l&&(d=this.client.core.pairing.pairings.get(l).active)}catch(P){throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`),P}if(!l||!d){const{topic:P,uri:v}=await this.client.core.pairing.create();l=P,h=v}if(!l){const{message:P}=s.getInternalError("NO_MATCHING_KEY",`connect() pairing topic: ${l}`);throw new Error(P)}const u=await this.client.core.crypto.generateKeyPair(),p=S.wc_sessionPropose.req.ttl||E.FIVE_MINUTES,w=s.calcExpiry(p),y=I({requiredNamespaces:r,optionalNamespaces:n,relays:c??[{protocol:N.RELAYER_DEFAULT_PROTOCOL}],proposer:{publicKey:u,metadata:this.client.metadata},expiryTimestamp:w,pairingTopic:l},a&&{sessionProperties:a}),{reject:_,resolve:T,done:R}=s.createDelayedPromise(p,he);this.events.once(s.engineEvent("session_connect"),async({error:P,session:v})=>{if(P)_(P);else if(v){v.self.publicKey=u;const x=C(I({},v),{pairingTopic:y.pairingTopic,requiredNamespaces:y.requiredNamespaces,optionalNamespaces:y.optionalNamespaces});await this.client.session.set(v.topic,x),await this.setExpiry(v.topic,v.expiry),l&&await this.client.core.pairing.updateMetadata({topic:l,metadata:v.peer.metadata}),this.cleanupDuplicatePairings(x),T(x)}});const q=await this.sendRequest({topic:l,method:"wc_sessionPropose",params:y,throwOnFailedPublish:!0});return await this.setProposal(q,I({id:q},y)),{uri:h,approval:R}},this.pair=async t=>{await this.isInitialized();try{return await this.client.core.pairing.pair(t)}catch(e){throw this.client.logger.error("pair() failed"),e}},this.approve=async t=>{await this.isInitialized();try{await this.isValidApprove(t)}catch(R){throw this.client.logger.error("approve() -> isValidApprove() failed"),R}const{id:e,relayProtocol:i,namespaces:r,sessionProperties:n,sessionConfig:a}=t;let c;try{c=this.client.proposal.get(e)}catch(R){throw this.client.logger.error(`approve() -> proposal.get(${e}) failed`),R}const{pairingTopic:l,proposer:h,requiredNamespaces:d,optionalNamespaces:u}=c,p=await this.client.core.crypto.generateKeyPair(),w=h.publicKey,y=await this.client.core.crypto.generateSharedKey(p,w),_=I(I({relay:{protocol:i??"irn"},namespaces:r,controller:{publicKey:p,metadata:this.client.metadata},expiry:s.calcExpiry(V)},n&&{sessionProperties:n}),a&&{sessionConfig:a});await this.client.core.relayer.subscribe(y);const T=C(I({},_),{topic:y,requiredNamespaces:d,optionalNamespaces:u,pairingTopic:l,acknowledged:!1,self:_.controller,peer:{publicKey:h.publicKey,metadata:h.metadata},controller:p});await this.client.session.set(y,T);try{await this.sendResult({id:e,topic:l,result:{relay:{protocol:i??"irn"},responderPublicKey:p},throwOnFailedPublish:!0}),await this.sendRequest({topic:y,method:"wc_sessionSettle",params:_,throwOnFailedPublish:!0})}catch(R){throw this.client.logger.error(R),this.client.session.delete(y,s.getSdkError("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(y),R}return await this.client.core.pairing.updateMetadata({topic:l,metadata:h.metadata}),await this.client.proposal.delete(e,s.getSdkError("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:l}),await this.setExpiry(y,s.calcExpiry(V)),{topic:y,acknowledged:()=>new Promise(R=>setTimeout(()=>R(this.client.session.get(y)),500))}},this.reject=async t=>{await this.isInitialized();try{await this.isValidReject(t)}catch(n){throw this.client.logger.error("reject() -> isValidReject() failed"),n}const{id:e,reason:i}=t;let r;try{r=this.client.proposal.get(e).pairingTopic}catch(n){throw this.client.logger.error(`reject() -> proposal.get(${e}) failed`),n}r&&(await this.sendError({id:e,topic:r,error:i,rpcOpts:S.wc_sessionPropose.reject}),await this.client.proposal.delete(e,s.getSdkError("USER_DISCONNECTED")))},this.update=async t=>{await this.isInitialized();try{await this.isValidUpdate(t)}catch(d){throw this.client.logger.error("update() -> isValidUpdate() failed"),d}const{topic:e,namespaces:i}=t,{done:r,resolve:n,reject:a}=s.createDelayedPromise(),c=g.payloadId(),l=g.getBigIntRpcId().toString(),h=this.client.session.get(e).namespaces;return this.events.once(s.engineEvent("session_update",c),({error:d})=>{d?a(d):n()}),await this.client.session.update(e,{namespaces:i}),await this.sendRequest({topic:e,method:"wc_sessionUpdate",params:{namespaces:i},throwOnFailedPublish:!0,clientRpcId:c,relayRpcId:l}).catch(d=>{this.client.logger.error(d),this.client.session.update(e,{namespaces:h}),a(d)}),{acknowledged:r}},this.extend=async t=>{await this.isInitialized();try{await this.isValidExtend(t)}catch(c){throw this.client.logger.error("extend() -> isValidExtend() failed"),c}const{topic:e}=t,i=g.payloadId(),{done:r,resolve:n,reject:a}=s.createDelayedPromise();return this.events.once(s.engineEvent("session_extend",i),({error:c})=>{c?a(c):n()}),await this.setExpiry(e,s.calcExpiry(V)),this.sendRequest({topic:e,method:"wc_sessionExtend",params:{},clientRpcId:i,throwOnFailedPublish:!0}).catch(c=>{a(c)}),{acknowledged:r}},this.request=async t=>{await this.isInitialized();try{await this.isValidRequest(t)}catch(p){throw this.client.logger.error("request() -> isValidRequest() failed"),p}const{chainId:e,request:i,topic:r,expiry:n=S.wc_sessionRequest.req.ttl}=t,a=this.client.session.get(r),c=g.payloadId(),l=g.getBigIntRpcId().toString(),{done:h,resolve:d,reject:u}=s.createDelayedPromise(n,"Request expired. Please try again.");return this.events.once(s.engineEvent("session_request",c),({error:p,result:w})=>{p?u(p):d(w)}),await Promise.all([new Promise(async p=>{await this.sendRequest({clientRpcId:c,relayRpcId:l,topic:r,method:"wc_sessionRequest",params:{request:C(I({},i),{expiryTimestamp:s.calcExpiry(n)}),chainId:e},expiry:n,throwOnFailedPublish:!0}).catch(w=>u(w)),this.client.events.emit("session_request_sent",{topic:r,request:i,chainId:e,id:c}),p()}),new Promise(async p=>{var w;if(!((w=a.sessionConfig)!=null&&w.disableDeepLink)){const y=await s.getDeepLink(this.client.core.storage,se);s.handleDeeplinkRedirect({id:c,topic:r,wcDeepLink:y})}p()}),h()]).then(p=>p[2])},this.respond=async t=>{await this.isInitialized(),await this.isValidRespond(t);const{topic:e,response:i}=t,{id:r}=i;g.isJsonRpcResult(i)?await this.sendResult({id:r,topic:e,result:i.result,throwOnFailedPublish:!0}):g.isJsonRpcError(i)&&await this.sendError({id:r,topic:e,error:i.error}),this.cleanupAfterResponse(t)},this.ping=async t=>{await this.isInitialized();try{await this.isValidPing(t)}catch(i){throw this.client.logger.error("ping() -> isValidPing() failed"),i}const{topic:e}=t;if(this.client.session.keys.includes(e)){const i=g.payloadId(),r=g.getBigIntRpcId().toString(),{done:n,resolve:a,reject:c}=s.createDelayedPromise();this.events.once(s.engineEvent("session_ping",i),({error:l})=>{l?c(l):a()}),await Promise.all([this.sendRequest({topic:e,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:i,relayRpcId:r}),n()])}else this.client.core.pairing.pairings.keys.includes(e)&&await this.client.core.pairing.ping({topic:e})},this.emit=async t=>{await this.isInitialized(),await this.isValidEmit(t);const{topic:e,event:i,chainId:r}=t,n=g.getBigIntRpcId().toString();await this.sendRequest({topic:e,method:"wc_sessionEvent",params:{event:i,chainId:r},throwOnFailedPublish:!0,relayRpcId:n})},this.disconnect=async t=>{await this.isInitialized(),await this.isValidDisconnect(t);const{topic:e}=t;if(this.client.session.keys.includes(e))await this.sendRequest({topic:e,method:"wc_sessionDelete",params:s.getSdkError("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:e,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(e))await this.client.core.pairing.disconnect({topic:e});else{const{message:i}=s.getInternalError("MISMATCHED_TOPIC",`Session or pairing topic not found: ${e}`);throw new Error(i)}},this.find=t=>(this.isInitialized(),this.client.session.getAll().filter(e=>s.isSessionCompatible(e,t))),this.getPendingSessionRequests=()=>this.client.pendingRequest.getAll(),this.authenticate=async t=>{this.isInitialized(),this.isValidAuthenticate(t);const{chains:e,statement:i="",uri:r,domain:n,nonce:a,type:c,exp:l,nbf:h,methods:d=[],expiry:u}=t,p=[...t.resources||[]],{topic:w,uri:y}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"]});this.client.logger.info({message:"Generated new pairing",pairing:{topic:w,uri:y}});const _=await this.client.core.crypto.generateKeyPair(),T=s.hashKey(_);if(await Promise.all([this.client.auth.authKeys.set($,{responseTopic:T,publicKey:_}),this.client.auth.pairingTopics.set(T,{topic:T,pairingTopic:w})]),await this.client.core.relayer.subscribe(T),this.client.logger.info(`sending request to new pairing topic: ${w}`),d.length>0){const{namespace:O}=s.parseChainId(e[0]);let f=s.createEncodedRecap(O,"request",d);s.getRecapFromResources(p)&&(f=s.mergeEncodedRecaps(f,p.pop())),p.push(f)}const R=u&&u>S.wc_sessionAuthenticate.req.ttl?u:S.wc_sessionAuthenticate.req.ttl,q={authPayload:{type:c??"caip122",chains:e,statement:i,aud:r,domain:n,version:"1",nonce:a,iat:new Date().toISOString(),exp:l,nbf:h,resources:p},requester:{publicKey:_,metadata:this.client.metadata},expiryTimestamp:s.calcExpiry(R)},P={eip155:{chains:e,methods:[...new Set(["personal_sign",...d])],events:["chainChanged","accountsChanged"]}},v={requiredNamespaces:{},optionalNamespaces:P,relays:[{protocol:"irn"}],pairingTopic:w,proposer:{publicKey:_,metadata:this.client.metadata},expiryTimestamp:s.calcExpiry(S.wc_sessionPropose.req.ttl)},{done:x,resolve:re,reject:X}=s.createDelayedPromise(R,"Request expired"),K=async({error:O,session:f})=>{if(this.events.off(s.engineEvent("session_request",D),J),O)X(O);else if(f){f.self.publicKey=_,await this.client.session.set(f.topic,f),await this.setExpiry(f.topic,f.expiry),w&&await this.client.core.pairing.updateMetadata({topic:w,metadata:f.peer.metadata});const M=this.client.session.get(f.topic);await this.deleteProposal(b),re({session:M})}},J=async O=>{if(await this.deletePendingAuthRequest(D,{message:"fulfilled",code:0}),O.error){const L=s.getSdkError("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return O.error.code===L.code?void 0:(this.events.off(s.engineEvent("session_connect"),K),X(O.error.message))}await this.deleteProposal(b),this.events.off(s.engineEvent("session_connect"),K);const{cacaos:f,responder:M}=O.result,z=[],ne=[];for(const L of f){await s.validateSignedCacao({cacao:L,projectId:this.client.core.projectId})||(this.client.logger.error(L,"Signature verification failed"),X(s.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:B}=L,W=s.getRecapFromResources(B.resources),oe=[s.getNamespacedDidChainId(B.iss)],fe=s.getDidAddress(B.iss);if(W){const Z=s.getMethodsFromRecap(W),Ne=s.getChainsFromRecap(W);z.push(...Z),oe.push(...Ne)}for(const Z of oe)ne.push(`${Z}:${fe}`)}const G=await this.client.core.crypto.generateSharedKey(_,M.publicKey);let F;z.length>0&&(F={topic:G,acknowledged:!0,self:{publicKey:_,metadata:this.client.metadata},peer:M,controller:M.publicKey,expiry:s.calcExpiry(V),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:w,namespaces:s.buildNamespacesFromAuth([...new Set(z)],[...new Set(ne)])},await this.client.core.relayer.subscribe(G),await this.client.session.set(G,F),F=this.client.session.get(G)),re({auths:f,session:F})},D=g.payloadId(),b=g.payloadId();this.events.once(s.engineEvent("session_connect"),K),this.events.once(s.engineEvent("session_request",D),J);try{await Promise.all([this.sendRequest({topic:w,method:"wc_sessionAuthenticate",params:q,expiry:t.expiry,throwOnFailedPublish:!0,clientRpcId:D}),this.sendRequest({topic:w,method:"wc_sessionPropose",params:v,expiry:S.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:b})])}catch(O){throw this.events.off(s.engineEvent("session_connect"),K),this.events.off(s.engineEvent("session_request",D),J),O}return await this.setProposal(b,I({id:b},v)),await this.setAuthRequest(D,{request:C(I({},q),{verifyContext:{}}),pairingTopic:w}),{uri:y,response:x}},this.approveSessionAuthenticate=async t=>{this.isInitialized();const{id:e,auths:i}=t,r=this.getPendingAuthRequest(e);if(!r)throw new Error(`Could not find pending auth request with id ${e}`);const n=r.requester.publicKey,a=await this.client.core.crypto.generateKeyPair(),c=s.hashKey(n),l={type:s.TYPE_1,receiverPublicKey:n,senderPublicKey:a},h=[],d=[];for(const w of i){if(!await s.validateSignedCacao({cacao:w,projectId:this.client.core.projectId})){const q=s.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:e,topic:c,error:q,encodeOpts:l}),new Error(q.message)}const{p:y}=w,_=s.getRecapFromResources(y.resources),T=[s.getNamespacedDidChainId(y.iss)],R=s.getDidAddress(y.iss);if(_){const q=s.getMethodsFromRecap(_),P=s.getChainsFromRecap(_);h.push(...q),T.push(...P)}for(const q of T)d.push(`${q}:${R}`)}const u=await this.client.core.crypto.generateSharedKey(a,n);let p;return h?.length>0&&(p={topic:u,acknowledged:!0,self:{publicKey:a,metadata:this.client.metadata},peer:{publicKey:n,metadata:r.requester.metadata},controller:n,expiry:s.calcExpiry(V),authentication:i,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:"",namespaces:s.buildNamespacesFromAuth([...new Set(h)],[...new Set(d)])},await this.client.core.relayer.subscribe(u),await this.client.session.set(u,p)),await this.sendResult({topic:c,id:e,result:{cacaos:i,responder:{publicKey:a,metadata:this.client.metadata}},encodeOpts:l,throwOnFailedPublish:!0}),await this.client.auth.requests.delete(e,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:r.pairingTopic}),{session:p}},this.rejectSessionAuthenticate=async t=>{await this.isInitialized();const{id:e,reason:i}=t,r=this.getPendingAuthRequest(e);if(!r)throw new Error(`Could not find pending auth request with id ${e}`);const n=r.requester.publicKey,a=await this.client.core.crypto.generateKeyPair(),c=s.hashKey(n),l={type:s.TYPE_1,receiverPublicKey:n,senderPublicKey:a};await this.sendError({id:e,topic:c,error:i,encodeOpts:l,rpcOpts:S.wc_sessionAuthenticate.reject}),await this.client.auth.requests.delete(e,{message:"rejected",code:0}),await this.client.proposal.delete(e,s.getSdkError("USER_DISCONNECTED"))},this.formatAuthMessage=t=>{this.isInitialized();const{request:e,iss:i}=t;return s.formatMessage(e,i)},this.cleanupDuplicatePairings=async t=>{if(t.pairingTopic)try{const e=this.client.core.pairing.pairings.get(t.pairingTopic),i=this.client.core.pairing.pairings.getAll().filter(r=>{var n,a;return((n=r.peerMetadata)==null?void 0:n.url)&&((a=r.peerMetadata)==null?void 0:a.url)===t.peer.metadata.url&&r.topic&&r.topic!==e.topic});if(i.length===0)return;this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`),await Promise.all(i.map(r=>this.client.core.pairing.disconnect({topic:r.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(e){this.client.logger.error(e)}},this.deleteSession=async t=>{var e;const{topic:i,expirerHasDeleted:r=!1,emitEvent:n=!0,id:a=0}=t,{self:c}=this.client.session.get(i);await this.client.core.relayer.unsubscribe(i),await this.client.session.delete(i,s.getSdkError("USER_DISCONNECTED")),this.addToRecentlyDeleted(i,"session"),this.client.core.crypto.keychain.has(c.publicKey)&&await this.client.core.crypto.deleteKeyPair(c.publicKey),this.client.core.crypto.keychain.has(i)&&await this.client.core.crypto.deleteSymKey(i),r||this.client.core.expirer.del(i),this.client.core.storage.removeItem(se).catch(l=>this.client.logger.warn(l)),this.getPendingSessionRequests().forEach(l=>{l.topic===i&&this.deletePendingSessionRequest(l.id,s.getSdkError("USER_DISCONNECTED"))}),i===((e=this.sessionRequestQueue.queue[0])==null?void 0:e.topic)&&(this.sessionRequestQueue.state=A.idle),n&&this.client.events.emit("session_delete",{id:a,topic:i})},this.deleteProposal=async(t,e)=>{await Promise.all([this.client.proposal.delete(t,s.getSdkError("USER_DISCONNECTED")),e?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")},this.deletePendingSessionRequest=async(t,e,i=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,e),i?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(r=>r.id!==t),i&&(this.sessionRequestQueue.state=A.idle,this.client.events.emit("session_request_expire",{id:t}))},this.deletePendingAuthRequest=async(t,e,i=!1)=>{await Promise.all([this.client.auth.requests.delete(t,e),i?Promise.resolve():this.client.core.expirer.del(t)])},this.setExpiry=async(t,e)=>{this.client.session.keys.includes(t)&&(this.client.core.expirer.set(t,e),await this.client.session.update(t,{expiry:e}))},this.setProposal=async(t,e)=>{this.client.core.expirer.set(t,s.calcExpiry(S.wc_sessionPropose.req.ttl)),await this.client.proposal.set(t,e)},this.setAuthRequest=async(t,e)=>{const{request:i,pairingTopic:r}=e;this.client.core.expirer.set(t,i.expiryTimestamp),await this.client.auth.requests.set(t,{authPayload:i.authPayload,requester:i.requester,expiryTimestamp:i.expiryTimestamp,id:t,pairingTopic:r,verifyContext:i.verifyContext})},this.setPendingSessionRequest=async t=>{const{id:e,topic:i,params:r,verifyContext:n}=t,a=r.request.expiryTimestamp||s.calcExpiry(S.wc_sessionRequest.req.ttl);this.client.core.expirer.set(e,a),await this.client.pendingRequest.set(e,{id:e,topic:i,params:r,verifyContext:n})},this.sendRequest=async t=>{const{topic:e,method:i,params:r,expiry:n,relayRpcId:a,clientRpcId:c,throwOnFailedPublish:l}=t,h=g.formatJsonRpcRequest(i,r,c);if(s.isBrowser()&&ge.includes(i)){const p=s.hashMessage(JSON.stringify(h));this.client.core.verify.register({attestationId:p})}let d;try{d=await this.client.core.crypto.encode(e,h)}catch(p){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e} failed`),p}const u=S[i].req;return n&&(u.ttl=n),a&&(u.id=a),this.client.core.history.set(e,h),l?(u.internal=C(I({},u.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(e,d,u)):this.client.core.relayer.publish(e,d,u).catch(p=>this.client.logger.error(p)),h.id},this.sendResult=async t=>{const{id:e,topic:i,result:r,throwOnFailedPublish:n,encodeOpts:a}=t,c=g.formatJsonRpcResult(e,r);let l;try{l=await this.client.core.crypto.encode(i,c,a)}catch(u){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i} failed`),u}let h;try{h=await this.client.core.history.get(i,e)}catch(u){throw this.client.logger.error(`sendResult() -> history.get(${i}, ${e}) failed`),u}const d=S[h.request.method].res;n?(d.internal=C(I({},d.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(i,l,d)):this.client.core.relayer.publish(i,l,d).catch(u=>this.client.logger.error(u)),await this.client.core.history.resolve(c)},this.sendError=async t=>{const{id:e,topic:i,error:r,encodeOpts:n,rpcOpts:a}=t,c=g.formatJsonRpcError(e,r);let l;try{l=await this.client.core.crypto.encode(i,c,n)}catch(u){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i} failed`),u}let h;try{h=await this.client.core.history.get(i,e)}catch(u){throw this.client.logger.error(`sendError() -> history.get(${i}, ${e}) failed`),u}const d=a||S[h.request.method].res;this.client.core.relayer.publish(i,l,d),await this.client.core.history.resolve(c)},this.cleanup=async()=>{const t=[],e=[];this.client.session.getAll().forEach(i=>{let r=!1;s.isExpired(i.expiry)&&(r=!0),this.client.core.crypto.keychain.has(i.topic)||(r=!0),r&&t.push(i.topic)}),this.client.proposal.getAll().forEach(i=>{s.isExpired(i.expiryTimestamp)&&e.push(i.id)}),await Promise.all([...t.map(i=>this.deleteSession({topic:i})),...e.map(i=>this.deleteProposal(i))])},this.onRelayEventRequest=async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()},this.processRequestsQueue=async()=>{if(this.requestQueue.state===A.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=A.active;const t=this.requestQueue.queue.shift();if(t)try{this.processRequest(t),await new Promise(e=>setTimeout(e,300))}catch(e){this.client.logger.warn(e)}}this.requestQueue.state=A.idle},this.processRequest=t=>{const{topic:e,payload:i}=t,r=i.method;if(!this.shouldIgnorePairingRequest({topic:e,requestMethod:r}))switch(r){case"wc_sessionPropose":return this.onSessionProposeRequest(e,i);case"wc_sessionSettle":return this.onSessionSettleRequest(e,i);case"wc_sessionUpdate":return this.onSessionUpdateRequest(e,i);case"wc_sessionExtend":return this.onSessionExtendRequest(e,i);case"wc_sessionPing":return this.onSessionPingRequest(e,i);case"wc_sessionDelete":return this.onSessionDeleteRequest(e,i);case"wc_sessionRequest":return this.onSessionRequest(e,i);case"wc_sessionEvent":return this.onSessionEventRequest(e,i);case"wc_sessionAuthenticate":return this.onSessionAuthenticateRequest(e,i);default:return this.client.logger.info(`Unsupported request method ${r}`)}},this.onRelayEventResponse=async t=>{const{topic:e,payload:i}=t,r=(await this.client.core.history.get(e,i.id)).request.method;switch(r){case"wc_sessionPropose":return this.onSessionProposeResponse(e,i);case"wc_sessionSettle":return this.onSessionSettleResponse(e,i);case"wc_sessionUpdate":return this.onSessionUpdateResponse(e,i);case"wc_sessionExtend":return this.onSessionExtendResponse(e,i);case"wc_sessionPing":return this.onSessionPingResponse(e,i);case"wc_sessionRequest":return this.onSessionRequestResponse(e,i);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(e,i);default:return this.client.logger.info(`Unsupported response method ${r}`)}},this.onRelayEventUnknownPayload=t=>{const{topic:e}=t,{message:i}=s.getInternalError("MISSING_OR_INVALID",`Decoded payload on topic ${e} is not identifiable as a JSON-RPC request or a response.`);throw new Error(i)},this.shouldIgnorePairingRequest=t=>{const{topic:e,requestMethod:i}=t,r=this.expectedPairingMethodMap.get(e);return!r||r.includes(i)?!1:!!(r.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)},this.onSessionProposeRequest=async(t,e)=>{const{params:i,id:r}=e;try{this.isValidConnect(I({},e.params));const n=i.expiryTimestamp||s.calcExpiry(S.wc_sessionPropose.req.ttl),a=I({id:r,pairingTopic:t,expiryTimestamp:n},i);await this.setProposal(r,a);const c=s.hashMessage(JSON.stringify(e)),l=await this.getVerifyContext(c,a.proposer.metadata);this.client.events.emit("session_proposal",{id:r,params:a,verifyContext:l})}catch(n){await this.sendError({id:r,topic:t,error:n,rpcOpts:S.wc_sessionPropose.autoReject}),this.client.logger.error(n)}},this.onSessionProposeResponse=async(t,e)=>{const{id:i}=e;if(g.isJsonRpcResult(e)){const{result:r}=e;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:r});const n=this.client.proposal.get(i);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:n});const a=n.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:a});const c=r.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:c});const l=await this.client.core.crypto.generateSharedKey(a,c);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:l});const h=await this.client.core.relayer.subscribe(l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:h}),await this.client.core.pairing.activate({topic:t})}else if(g.isJsonRpcError(e)){await this.client.proposal.delete(i,s.getSdkError("USER_DISCONNECTED"));const r=s.engineEvent("session_connect");if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners, 954`);this.events.emit(s.engineEvent("session_connect"),{error:e.error})}},this.onSessionSettleRequest=async(t,e)=>{const{id:i,params:r}=e;try{this.isValidSessionSettleRequest(r);const{relay:n,controller:a,expiry:c,namespaces:l,sessionProperties:h,sessionConfig:d}=e.params,u=I(I({topic:t,relay:n,expiry:c,namespaces:l,acknowledged:!0,pairingTopic:"",requiredNamespaces:{},optionalNamespaces:{},controller:a.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:a.publicKey,metadata:a.metadata}},h&&{sessionProperties:h}),d&&{sessionConfig:d});await this.sendResult({id:e.id,topic:t,result:!0,throwOnFailedPublish:!0});const p=s.engineEvent("session_connect");if(this.events.listenerCount(p)===0)throw new Error(`emitting ${p} without any listeners 997`);this.events.emit(s.engineEvent("session_connect"),{session:u})}catch(n){await this.sendError({id:i,topic:t,error:n}),this.client.logger.error(n)}},this.onSessionSettleResponse=async(t,e)=>{const{id:i}=e;g.isJsonRpcResult(e)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit(s.engineEvent("session_approve",i),{})):g.isJsonRpcError(e)&&(await this.client.session.delete(t,s.getSdkError("USER_DISCONNECTED")),this.events.emit(s.engineEvent("session_approve",i),{error:e.error}))},this.onSessionUpdateRequest=async(t,e)=>{const{params:i,id:r}=e;try{const n=`${t}_session_update`,a=s.MemoryStore.get(n);if(a&&this.isRequestOutOfSync(a,r)){this.client.logger.info(`Discarding out of sync request - ${r}`),this.sendError({id:r,topic:t,error:s.getSdkError("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(I({topic:t},i));try{s.MemoryStore.set(n,r),await this.client.session.update(t,{namespaces:i.namespaces}),await this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0})}catch(c){throw s.MemoryStore.delete(n),c}this.client.events.emit("session_update",{id:r,topic:t,params:i})}catch(n){await this.sendError({id:r,topic:t,error:n}),this.client.logger.error(n)}},this.isRequestOutOfSync=(t,e)=>parseInt(e.toString().slice(0,-3))<=parseInt(t.toString().slice(0,-3)),this.onSessionUpdateResponse=(t,e)=>{const{id:i}=e,r=s.engineEvent("session_update",i);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);g.isJsonRpcResult(e)?this.events.emit(s.engineEvent("session_update",i),{}):g.isJsonRpcError(e)&&this.events.emit(s.engineEvent("session_update",i),{error:e.error})},this.onSessionExtendRequest=async(t,e)=>{const{id:i}=e;try{this.isValidExtend({topic:t}),await this.setExpiry(t,s.calcExpiry(V)),await this.sendResult({id:i,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:i,topic:t})}catch(r){await this.sendError({id:i,topic:t,error:r}),this.client.logger.error(r)}},this.onSessionExtendResponse=(t,e)=>{const{id:i}=e,r=s.engineEvent("session_extend",i);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);g.isJsonRpcResult(e)?this.events.emit(s.engineEvent("session_extend",i),{}):g.isJsonRpcError(e)&&this.events.emit(s.engineEvent("session_extend",i),{error:e.error})},this.onSessionPingRequest=async(t,e)=>{const{id:i}=e;try{this.isValidPing({topic:t}),await this.sendResult({id:i,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:i,topic:t})}catch(r){await this.sendError({id:i,topic:t,error:r}),this.client.logger.error(r)}},this.onSessionPingResponse=(t,e)=>{const{id:i}=e,r=s.engineEvent("session_ping",i);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);setTimeout(()=>{g.isJsonRpcResult(e)?this.events.emit(s.engineEvent("session_ping",i),{}):g.isJsonRpcError(e)&&this.events.emit(s.engineEvent("session_ping",i),{error:e.error})},500)},this.onSessionDeleteRequest=async(t,e)=>{const{id:i}=e;try{this.isValidDisconnect({topic:t,reason:e.params}),await Promise.all([new Promise(r=>{this.client.core.relayer.once(N.RELAYER_EVENTS.publish,async()=>{r(await this.deleteSession({topic:t,id:i}))})}),this.sendResult({id:i,topic:t,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:s.getSdkError("USER_DISCONNECTED")})])}catch(r){this.client.logger.error(r)}},this.onSessionRequest=async(t,e)=>{var i;const{id:r,params:n}=e;try{await this.isValidRequest(I({topic:t},n));const a=s.hashMessage(JSON.stringify(g.formatJsonRpcRequest("wc_sessionRequest",n,r))),c=this.client.session.get(t),l=await this.getVerifyContext(a,c.peer.metadata),h={id:r,topic:t,params:n,verifyContext:l};await this.setPendingSessionRequest(h),(i=this.client.signConfig)!=null&&i.disableRequestQueue?this.emitSessionRequest(h):(this.addSessionRequestToSessionRequestQueue(h),this.processSessionRequestQueue())}catch(a){await this.sendError({id:r,topic:t,error:a}),this.client.logger.error(a)}},this.onSessionRequestResponse=(t,e)=>{const{id:i}=e,r=s.engineEvent("session_request",i);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);g.isJsonRpcResult(e)?this.events.emit(s.engineEvent("session_request",i),{result:e.result}):g.isJsonRpcError(e)&&this.events.emit(s.engineEvent("session_request",i),{error:e.error})},this.onSessionEventRequest=async(t,e)=>{const{id:i,params:r}=e;try{const n=`${t}_session_event_${r.event.name}`,a=s.MemoryStore.get(n);if(a&&this.isRequestOutOfSync(a,i)){this.client.logger.info(`Discarding out of sync request - ${i}`);return}this.isValidEmit(I({topic:t},r)),this.client.events.emit("session_event",{id:i,topic:t,params:r}),s.MemoryStore.set(n,i)}catch(n){await this.sendError({id:i,topic:t,error:n}),this.client.logger.error(n)}},this.onSessionAuthenticateResponse=(t,e)=>{const{id:i}=e;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:t,payload:e}),g.isJsonRpcResult(e)?this.events.emit(s.engineEvent("session_request",i),{result:e.result}):g.isJsonRpcError(e)&&this.events.emit(s.engineEvent("session_request",i),{error:e.error})},this.onSessionAuthenticateRequest=async(t,e)=>{try{const{requester:i,authPayload:r,expiryTimestamp:n}=e.params,a=s.hashMessage(JSON.stringify(e)),c=await this.getVerifyContext(a,this.client.metadata),l={requester:i,pairingTopic:t,id:e.id,authPayload:r,verifyContext:c,expiryTimestamp:n};await this.setAuthRequest(e.id,{request:l,pairingTopic:t}),this.client.events.emit("session_authenticate",{topic:t,params:e.params,id:e.id})}catch(i){this.client.logger.error(i);const r=e.params.requester.publicKey,n=await this.client.core.crypto.generateKeyPair(),a={type:s.TYPE_1,receiverPublicKey:r,senderPublicKey:n};await this.sendError({id:e.id,topic:t,error:i,encodeOpts:a,rpcOpts:S.wc_sessionAuthenticate.autoReject})}},this.addSessionRequestToSessionRequestQueue=t=>{this.sessionRequestQueue.queue.push(t)},this.cleanupAfterResponse=t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=A.idle,this.processSessionRequestQueue()},E.toMiliseconds(this.requestQueueDelay))},this.cleanupPendingSentRequestsForTopic=({topic:t,error:e})=>{const i=this.client.core.history.pending;i.length>0&&i.filter(r=>r.topic===t&&r.request.method==="wc_sessionRequest").forEach(r=>{const n=r.request.id,a=s.engineEvent("session_request",n);if(this.events.listenerCount(a)===0)throw new Error(`emitting ${a} without any listeners`);this.events.emit(s.engineEvent("session_request",r.request.id),{error:e})})},this.processSessionRequestQueue=()=>{if(this.sessionRequestQueue.state===A.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=A.active,this.emitSessionRequest(t)}catch(e){this.client.logger.error(e)}},this.emitSessionRequest=t=>{this.client.events.emit("session_request",t)},this.onPairingCreated=t=>{if(t.methods&&this.expectedPairingMethodMap.set(t.topic,t.methods),t.active)return;const e=this.client.proposal.getAll().find(i=>i.pairingTopic===t.topic);e&&this.onSessionProposeRequest(t.topic,g.formatJsonRpcRequest("wc_sessionPropose",{requiredNamespaces:e.requiredNamespaces,optionalNamespaces:e.optionalNamespaces,relays:e.relays,proposer:e.proposer,sessionProperties:e.sessionProperties},e.id))},this.isValidConnect=async t=>{if(!s.isValidParams(t)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(c)}const{pairingTopic:e,requiredNamespaces:i,optionalNamespaces:r,sessionProperties:n,relays:a}=t;if(s.isUndefined(e)||await this.isValidPairingTopic(e),!s.isValidRelays(a,!0)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`connect() relays: ${a}`);throw new Error(c)}!s.isUndefined(i)&&s.isValidObject(i)!==0&&this.validateNamespaces(i,"requiredNamespaces"),!s.isUndefined(r)&&s.isValidObject(r)!==0&&this.validateNamespaces(r,"optionalNamespaces"),s.isUndefined(n)||this.validateSessionProps(n,"sessionProperties")},this.validateNamespaces=(t,e)=>{const i=s.isValidRequiredNamespaces(t,"connect()",e);if(i)throw new Error(i.message)},this.isValidApprove=async t=>{if(!s.isValidParams(t))throw new Error(s.getInternalError("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:e,namespaces:i,relayProtocol:r,sessionProperties:n}=t;this.checkRecentlyDeleted(e),await this.isValidProposalId(e);const a=this.client.proposal.get(e),c=s.isValidNamespaces(i,"approve()");if(c)throw new Error(c.message);const l=s.isConformingNamespaces(a.requiredNamespaces,i,"approve()");if(l)throw new Error(l.message);if(!s.isValidString(r,!0)){const{message:h}=s.getInternalError("MISSING_OR_INVALID",`approve() relayProtocol: ${r}`);throw new Error(h)}s.isUndefined(n)||this.validateSessionProps(n,"sessionProperties")},this.isValidReject=async t=>{if(!s.isValidParams(t)){const{message:r}=s.getInternalError("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(r)}const{id:e,reason:i}=t;if(this.checkRecentlyDeleted(e),await this.isValidProposalId(e),!s.isValidErrorReason(i)){const{message:r}=s.getInternalError("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(i)}`);throw new Error(r)}},this.isValidSessionSettleRequest=t=>{if(!s.isValidParams(t)){const{message:l}=s.getInternalError("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(l)}const{relay:e,controller:i,namespaces:r,expiry:n}=t;if(!s.isValidRelay(e)){const{message:l}=s.getInternalError("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const a=s.isValidController(i,"onSessionSettleRequest()");if(a)throw new Error(a.message);const c=s.isValidNamespaces(r,"onSessionSettleRequest()");if(c)throw new Error(c.message);if(s.isExpired(n)){const{message:l}=s.getInternalError("EXPIRED","onSessionSettleRequest()");throw new Error(l)}},this.isValidUpdate=async t=>{if(!s.isValidParams(t)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(c)}const{topic:e,namespaces:i}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const r=this.client.session.get(e),n=s.isValidNamespaces(i,"update()");if(n)throw new Error(n.message);const a=s.isConformingNamespaces(r.requiredNamespaces,i,"update()");if(a)throw new Error(a.message)},this.isValidExtend=async t=>{if(!s.isValidParams(t)){const{message:i}=s.getInternalError("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(i)}const{topic:e}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e)},this.isValidRequest=async t=>{if(!s.isValidParams(t)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(c)}const{topic:e,request:i,chainId:r,expiry:n}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const{namespaces:a}=this.client.session.get(e);if(!s.isValidNamespacesChainId(a,r)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`request() chainId: ${r}`);throw new Error(c)}if(!s.isValidRequest(i)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`request() ${JSON.stringify(i)}`);throw new Error(c)}if(!s.isValidNamespacesRequest(a,r,i.method)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`request() method: ${i.method}`);throw new Error(c)}if(n&&!s.isValidRequestExpiry(n,Q)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${Q.min} and ${Q.max}`);throw new Error(c)}},this.isValidRespond=async t=>{var e;if(!s.isValidParams(t)){const{message:n}=s.getInternalError("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(n)}const{topic:i,response:r}=t;try{await this.isValidSessionTopic(i)}catch(n){throw(e=t?.response)!=null&&e.id&&this.cleanupAfterResponse(t),n}if(!s.isValidResponse(r)){const{message:n}=s.getInternalError("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(r)}`);throw new Error(n)}},this.isValidPing=async t=>{if(!s.isValidParams(t)){const{message:i}=s.getInternalError("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(i)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)},this.isValidEmit=async t=>{if(!s.isValidParams(t)){const{message:a}=s.getInternalError("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(a)}const{topic:e,event:i,chainId:r}=t;await this.isValidSessionTopic(e);const{namespaces:n}=this.client.session.get(e);if(!s.isValidNamespacesChainId(n,r)){const{message:a}=s.getInternalError("MISSING_OR_INVALID",`emit() chainId: ${r}`);throw new Error(a)}if(!s.isValidEvent(i)){const{message:a}=s.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(i)}`);throw new Error(a)}if(!s.isValidNamespacesEvent(n,r,i.name)){const{message:a}=s.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(i)}`);throw new Error(a)}},this.isValidDisconnect=async t=>{if(!s.isValidParams(t)){const{message:i}=s.getInternalError("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(i)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)},this.isValidAuthenticate=t=>{const{chains:e,uri:i,domain:r,nonce:n}=t;if(!Array.isArray(e)||e.length===0)throw new Error("chains is required and must be a non-empty array");if(!s.isValidString(i,!1))throw new Error("uri is required parameter");if(!s.isValidString(r,!1))throw new Error("domain is required parameter");if(!s.isValidString(n,!1))throw new Error("nonce is required parameter");if([...new Set(e.map(c=>s.parseChainId(c).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:a}=s.parseChainId(e[0]);if(a!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")},this.getVerifyContext=async(t,e)=>{const i={verified:{verifyUrl:e.verifyUrl||N.VERIFY_SERVER,validation:"UNKNOWN",origin:e.url||""}};try{const r=await this.client.core.verify.resolve({attestationId:t,verifyUrl:e.verifyUrl});r&&(i.verified.origin=r.origin,i.verified.isScam=r.isScam,i.verified.validation=r.origin===new URL(e.url).origin?"VALID":"INVALID")}catch(r){this.client.logger.info(r)}return this.client.logger.info(`Verify context: ${JSON.stringify(i)}`),i},this.validateSessionProps=(t,e)=>{Object.values(t).forEach(i=>{if(!s.isValidString(i,!1)){const{message:r}=s.getInternalError("MISSING_OR_INVALID",`${e} must be in Record<string, string> format. Received: ${JSON.stringify(i)}`);throw new Error(r)}})},this.getPendingAuthRequest=t=>{const e=this.client.auth.requests.get(t);return typeof e=="object"?e:void 0},this.addToRecentlyDeleted=(t,e)=>{if(this.recentlyDeletedMap.set(t,e),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let i=0;const r=this.recentlyDeletedLimit/2;for(const n of this.recentlyDeletedMap.keys()){if(i++>=r)break;this.recentlyDeletedMap.delete(n)}}},this.checkRecentlyDeleted=t=>{const e=this.recentlyDeletedMap.get(t);if(e){const{message:i}=s.getInternalError("MISSING_OR_INVALID",`Record was recently deleted - ${e}: ${t}`);throw new Error(i)}}}async isInitialized(){if(!this.initialized){const{message:o}=s.getInternalError("NOT_INITIALIZED",this.name);throw new Error(o)}await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(N.RELAYER_EVENTS.message,async o=>{const{topic:t,message:e}=o,{publicKey:i}=this.client.auth.authKeys.keys.includes($)?this.client.auth.authKeys.get($):{responseTopic:void 0,publicKey:void 0},r=await this.client.core.crypto.decode(t,e,{receiverPublicKey:i});try{g.isJsonRpcRequest(r)?(this.client.core.history.set(t,r),this.onRelayEventRequest({topic:t,payload:r})):g.isJsonRpcResponse(r)?(await this.client.core.history.resolve(r),await this.onRelayEventResponse({topic:t,payload:r}),this.client.core.history.delete(t,r.id)):this.onRelayEventUnknownPayload({topic:t,payload:r})}catch(n){this.client.logger.error(n)}})}registerExpirerEvents(){this.client.core.expirer.on(N.EXPIRER_EVENTS.expired,async o=>{const{topic:t,id:e}=s.parseExpirerTarget(o.target);if(e&&this.client.pendingRequest.keys.includes(e))return await this.deletePendingSessionRequest(e,s.getInternalError("EXPIRED"),!0);if(e&&this.client.auth.requests.keys.includes(e))return await this.deletePendingAuthRequest(e,s.getInternalError("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):e&&(await this.deleteProposal(e,!0),this.client.events.emit("proposal_expire",{id:e}))})}registerPairingEvents(){this.client.core.pairing.events.on(N.PAIRING_EVENTS.create,o=>this.onPairingCreated(o)),this.client.core.pairing.events.on(N.PAIRING_EVENTS.delete,o=>{this.addToRecentlyDeleted(o.topic,"pairing")})}isValidPairingTopic(o){if(!s.isValidString(o,!1)){const{message:t}=s.getInternalError("MISSING_OR_INVALID",`pairing topic should be a string: ${o}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(o)){const{message:t}=s.getInternalError("NO_MATCHING_KEY",`pairing topic doesn't exist: ${o}`);throw new Error(t)}if(s.isExpired(this.client.core.pairing.pairings.get(o).expiry)){const{message:t}=s.getInternalError("EXPIRED",`pairing topic: ${o}`);throw new Error(t)}}async isValidSessionTopic(o){if(!s.isValidString(o,!1)){const{message:t}=s.getInternalError("MISSING_OR_INVALID",`session topic should be a string: ${o}`);throw new Error(t)}if(this.checkRecentlyDeleted(o),!this.client.session.keys.includes(o)){const{message:t}=s.getInternalError("NO_MATCHING_KEY",`session topic doesn't exist: ${o}`);throw new Error(t)}if(s.isExpired(this.client.session.get(o).expiry)){await this.deleteSession({topic:o});const{message:t}=s.getInternalError("EXPIRED",`session topic: ${o}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(o)){const{message:t}=s.getInternalError("MISSING_OR_INVALID",`session topic does not exist in keychain: ${o}`);throw await this.deleteSession({topic:o}),new Error(t)}}async isValidSessionOrPairingTopic(o){if(this.checkRecentlyDeleted(o),this.client.session.keys.includes(o))await this.isValidSessionTopic(o);else if(this.client.core.pairing.pairings.keys.includes(o))this.isValidPairingTopic(o);else if(s.isValidString(o,!1)){const{message:t}=s.getInternalError("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${o}`);throw new Error(t)}else{const{message:t}=s.getInternalError("MISSING_OR_INVALID",`session or pairing topic should be a string: ${o}`);throw new Error(t)}}async isValidProposalId(o){if(!s.isValidId(o)){const{message:t}=s.getInternalError("MISSING_OR_INVALID",`proposal id should be a number: ${o}`);throw new Error(t)}if(!this.client.proposal.keys.includes(o)){const{message:t}=s.getInternalError("NO_MATCHING_KEY",`proposal id doesn't exist: ${o}`);throw new Error(t)}if(s.isExpired(this.client.proposal.get(o).expiryTimestamp)){await this.deleteProposal(o);const{message:t}=s.getInternalError("EXPIRED",`proposal id: ${o}`);throw new Error(t)}}}class Ke extends N.Store{constructor(o,t){super(o,t,le,j),this.core=o,this.logger=t}}class Re extends N.Store{constructor(o,t){super(o,t,pe,j),this.core=o,this.logger=t}}class Ge extends N.Store{constructor(o,t){super(o,t,ue,j,e=>e.id),this.core=o,this.logger=t}}class Fe extends N.Store{constructor(o,t){super(o,t,ye,U,()=>$),this.core=o,this.logger=t}}class ke extends N.Store{constructor(o,t){super(o,t,me,U),this.core=o,this.logger=t}}class je extends N.Store{constructor(o,t){super(o,t,Ie,U,e=>e.id),this.core=o,this.logger=t}}class Ye{constructor(o,t){this.core=o,this.logger=t,this.authKeys=new Fe(this.core,this.logger),this.pairingTopics=new ke(this.core,this.logger),this.requests=new je(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}class H extends ae.ISignClient{constructor(o){super(o),this.protocol=ee,this.version=te,this.name=Y.name,this.events=new ce.EventEmitter,this.on=(e,i)=>this.events.on(e,i),this.once=(e,i)=>this.events.once(e,i),this.off=(e,i)=>this.events.off(e,i),this.removeListener=(e,i)=>this.events.removeListener(e,i),this.removeAllListeners=e=>this.events.removeAllListeners(e),this.connect=async e=>{try{return await this.engine.connect(e)}catch(i){throw this.logger.error(i.message),i}},this.pair=async e=>{try{return await this.engine.pair(e)}catch(i){throw this.logger.error(i.message),i}},this.approve=async e=>{try{return await this.engine.approve(e)}catch(i){throw this.logger.error(i.message),i}},this.reject=async e=>{try{return await this.engine.reject(e)}catch(i){throw this.logger.error(i.message),i}},this.update=async e=>{try{return await this.engine.update(e)}catch(i){throw this.logger.error(i.message),i}},this.extend=async e=>{try{return await this.engine.extend(e)}catch(i){throw this.logger.error(i.message),i}},this.request=async e=>{try{return await this.engine.request(e)}catch(i){throw this.logger.error(i.message),i}},this.respond=async e=>{try{return await this.engine.respond(e)}catch(i){throw this.logger.error(i.message),i}},this.ping=async e=>{try{return await this.engine.ping(e)}catch(i){throw this.logger.error(i.message),i}},this.emit=async e=>{try{return await this.engine.emit(e)}catch(i){throw this.logger.error(i.message),i}},this.disconnect=async e=>{try{return await this.engine.disconnect(e)}catch(i){throw this.logger.error(i.message),i}},this.find=e=>{try{return this.engine.find(e)}catch(i){throw this.logger.error(i.message),i}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(e){throw this.logger.error(e.message),e}},this.authenticate=async e=>{try{return await this.engine.authenticate(e)}catch(i){throw this.logger.error(i.message),i}},this.formatAuthMessage=e=>{try{return this.engine.formatAuthMessage(e)}catch(i){throw this.logger.error(i.message),i}},this.approveSessionAuthenticate=async e=>{try{return await this.engine.approveSessionAuthenticate(e)}catch(i){throw this.logger.error(i.message),i}},this.rejectSessionAuthenticate=async e=>{try{return await this.engine.rejectSessionAuthenticate(e)}catch(i){throw this.logger.error(i.message),i}},this.name=o?.name||Y.name,this.metadata=o?.metadata||s.getAppMetadata(),this.signConfig=o?.signConfig;const t=typeof o?.logger<"u"&&typeof o?.logger!="string"?o.logger:k.pino(k.getDefaultLoggerOptions({level:o?.logger||Y.logger}));this.core=o?.core||new N.Core(o),this.logger=k.generateChildLogger(t,this.name),this.session=new Re(this.core,this.logger),this.proposal=new Ke(this.core,this.logger),this.pendingRequest=new Ge(this.core,this.logger),this.engine=new $e(this),this.auth=new Ye(this.core,this.logger)}static async init(o){const t=new H(o);return await t.initialize(),t}get context(){return k.getLoggerContext(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),await this.auth.init(),this.core.verify.init({verifyUrl:this.metadata.verifyUrl}),this.logger.info("SignClient Initialization Success")}catch(o){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(o.message),o}}}const Qe=Re,He=H;exports.AUTH_CONTEXT=we,exports.AUTH_KEYS_CONTEXT=ye,exports.AUTH_PAIRING_TOPIC_CONTEXT=me,exports.AUTH_PROTOCOL=Ee,exports.AUTH_PUBLIC_KEY_NAME=$,exports.AUTH_REQUEST_CONTEXT=Ie,exports.AUTH_STORAGE_PREFIX=U,exports.AUTH_VERSION=De,exports.ENGINE_CONTEXT=de,exports.ENGINE_QUEUE_STATES=A,exports.ENGINE_RPC_OPTS=S,exports.HISTORY_CONTEXT=Ae,exports.HISTORY_EVENTS=Oe,exports.HISTORY_STORAGE_VERSION=Ve,exports.METHODS_TO_VERIFY=ge,exports.PROPOSAL_CONTEXT=le,exports.PROPOSAL_EXPIRY=Ce,exports.PROPOSAL_EXPIRY_MESSAGE=he,exports.REQUEST_CONTEXT=ue,exports.SESSION_CONTEXT=pe,exports.SESSION_EXPIRY=V,exports.SESSION_REQUEST_EXPIRY_BOUNDARIES=Q,exports.SIGN_CLIENT_CONTEXT=ie,exports.SIGN_CLIENT_DEFAULT=Y,exports.SIGN_CLIENT_EVENTS=ve,exports.SIGN_CLIENT_PROTOCOL=ee,exports.SIGN_CLIENT_STORAGE_OPTIONS=Te,exports.SIGN_CLIENT_STORAGE_PREFIX=j,exports.SIGN_CLIENT_VERSION=te,exports.SessionStore=Qe,exports.SignClient=He,exports.WALLETCONNECT_DEEPLINK_CHOICE=se,exports.default=H;
//# sourceMappingURL=index.cjs.js.map
